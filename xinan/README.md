# 记录一下西南大网教的笔记
- 计算机方面
1. 进制：
    - 阐述
    ```
    二进制由0、1组成，B表示二进制数
    八进制由0-7组成，O表示八进制数
    十六进制由0-9和A-F组成，A是10，F是15，H表示十六进制数
    
    ```
    - 任何进制转10进制
    ```
    例：
    100110(B) = 2^5 + 2^2 + 2 = 38 （2进制转10进制）
    62345(O) = 6x8^4 + 2x8^3 + 3x8^2 + 4x8^1 + 5x8^0 = 25829 （八进制转10进制）
    54323E(H) = 5x16^5 + 4x16^4 + 3x16^3 + 2x16^2 + 3x16^1 + 14x16^0 = 5517886 （16进制转10进制）
    ```
    ![image](https://github.com/zeng13445/mianshi/blob/main/images/进制转换.png)

3. ConcurrentHashMap：
    - 阐述
    ```
    其实就是同步的HashMap，底层数据结构依旧是数组+链表+红黑树（链表节点大于8转为红黑树）。在多线程场景下解决了hashmap死循环的问题。
    线程安全方式采用CAS + synchronized方式，又解决了hashtable在多线程场景下性能问题。
    ```
    - hashmap、hashtable、concurrenthashmap
    ![image](https://github.com/zeng13445/mianshi/blob/main/images/difference.png)
    
4. GC
    - gc作用
    ```
    gc垃圾回收机制，在适当的时候回收JVM垃圾，防止内存泄露，有效的使用可以使用的内存。
    ```
    - 什么时候触发
    ```
    ......
    ```
    - 对谁
    ```
    不再使用的对象。使用"引用计数法"、"可达性分析算法"判断对象是否还在被使用。
    引用计数法：给对象添加一个引用计数器，被引用时+1，引用失效-1。很难解决对象之间的互相循环引用（引用环问题）的问题。
    可达性分析算法（主流）：算法的基本思路就是以一系列的称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，
    当一个对象到GC Roots没有任何引用链相连的时候（即该对象不可达），则证明此对象是不可用的。在java中，可作为GC Roots的对象包括以下几种：
    栈中引用的对象（栈帧中的本地变量表）、方法区中类静态属性引用的对象、方法区中常量引用的对象。
    ```
    - 做了什么
    ```
    不可达的对象，如何被回收：1.标记清除法，2.复制算法，3.标记整理法，4.分代收集算法
    标记清除法：在标记（可达性算法标记）完成后统一回收所有被标记的对象。
    复制算法：将可用内存分为大小相同的两部分，每次只使用其中的一块，当使用的那一块内存快用尽时，就将还存活的对象复制到另外一块内存上，然后把已经使用过的内存空间一次性清理掉。
    标记整理法：标记过程不变，仍使用“可达性分析算法”，标记完后不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。
    分代收集算法：JVM在实际垃圾回收中实际使用的是分代收集算法：根据对象存活周期的不同将内存划分为：新生代和老年代。在新生代每次都只有少量对象存活，选用复制算法；
    老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记-整理法或是标记-清理法进行回收。
    ```
