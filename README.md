# 记录一下面试的笔记
- java
1. HashMap：
    - 阐述
    ```
    底层主要是基于数组外加链表组成，链表主要是为了解决hash冲突，还可解决数组插入数据效率低的问题。
    ```
    - 默认容量和扩容机制
    ```
    默认capacity 16，默认负载因子0.75，所有当大于12时才发生扩容（一倍）。扩容是很消耗性能的，所以最好提前预估初始大小以减少扩容带来的性能损耗。
    ```
    - put、get（1.8）
    ```
    根据key计算出hashcode，然后定位出所在的桶（当前位置），再将value放入。get类似，也是通过key算出hashcode，再定位到桶，取值。
    ```
     ![image](https://github.com/zeng13445/mianshi/blob/main/images/put.png)
    - 初始化
    ```
    若在构造函数中指定了容量大小7，那么该容量其实是8，因为hash会选择大于该数字的第一个2的n次幂作为容量（即3->4、7->8、9->16）。
    ```
2. ConcurrentHashMap：
    - 阐述
    ```
    其实就是同步的HashMap，底层数据结构依旧是数组+链表+红黑树（链表节点大于8转为红黑树）。在多线程场景下解决了hashmap死循环的问题。
    线程安全方式采用CAS + synchronized方式，又解决了hashtable在多线程场景下性能问题。
    ```
    - hashmap、hashtable、concurrenthashmap
    ![image](https://github.com/zeng13445/mianshi/blob/main/images/difference.png)
    
3. GC
    - gc作用
    ```
    gc垃圾回收机制，在适当的时候回收JVM垃圾，防止内存泄露，有效的使用可以使用的内存。
    ```
    - 什么时候触发
    ```
    ......
    ```
    - 对谁
    ```
    不再使用的对象。使用"引用计数法"、"可达性分析算法"判断对象是否还在被使用。
    引用计数法：给对象添加一个引用计数器，被引用时+1，引用失效-1。很难解决对象之间的互相循环引用（引用环问题）的问题。
    可达性分析算法（主流）：算法的基本思路就是以一系列的称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，
    当一个对象到GC Roots没有任何引用链相连的时候（即该对象不可达），则证明此对象是不可用的。在java中，可作为GC Roots的对象包括以下几种：
    栈中引用的对象（栈帧中的本地变量表）、方法区中类静态属性引用的对象、方法区中常量引用的对象。
    ```
    - 做了什么
    ```
    不可达的对象，如何被回收：1.标记清除法，2.复制算法，3.标记整理法，4.分代收集算法
    标记清除法：在标记（可达性算法标记）完成后统一回收所有被标记的对象。
    复制算法：将可用内存分为大小相同的两部分，每次只使用其中的一块，当使用的那一块内存快用尽时，就将还存活的对象复制到另外一块内存上，然后把已经使用过的内存空间一次性清理掉。
    标记整理法：标记过程不变，仍使用“可达性分析算法”，标记完后不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。
    分代收集算法：JVM在实际垃圾回收中实际使用的是分代收集算法：根据对象存活周期的不同将内存划分为：新生代和老年代。在新生代每次都只有少量对象存活，选用复制算法；
    老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记-整理法或是标记-清理法进行回收。
    ```
